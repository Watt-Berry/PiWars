// SPDX-FileCopyrightText: Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
// SPDX-License-Identifier: BSD-3-Clause
#include "vtkCellGridFS_DGHex.h"

const char *vtkCellGridFS_DGHex =
"//VTK::System::Dec\n"
"\n"
"//VTK::Define::Dec\n"
"\n"
"// SPDX-FileCopyrightText: Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"// SPDX-License-Identifier: BSD-3-Clause\n"
"// Template for the cellgrid mapper fragment shader\n"
"\n"
"// look up cell points, types and vertex positions from texture buffers.\n"
"uniform samplerBuffer fieldCoefficients;\n"
"uniform vec2 fieldRange;\n"
"\n"
"// These two help debug parametric coordinates and basis function values.\n"
"uniform int visualizePCoord;\n"
"uniform int visualizeBasisFunction;\n"
"uniform int mapScalars;\n"
"\n"
"//VTK::CustomUniforms::Dec\n"
"\n"
"// Camera prop\n"
"//VTK::Camera::Dec\n"
"\n"
"// Input parametric coord from geometry shader\n"
"in vec3 pCoordGSOutput;\n"
"\n"
"// Input VTK cell ID from vertex shader\n"
"flat in int vtkCellIdGSOutput;\n"
"\n"
"// optional color passed in from the vertex shader, vertexColor\n"
"//VTK::Color::Dec\n"
"\n"
"// cell Normal used to light up and shade the pixels.\n"
"//VTK::Normal::Dec\n"
"\n"
"// Lights\n"
"//VTK::Light::Dec\n"
"\n"
"// the output of this shader\n"
"//VTK::Output::Dec\n"
"\n"
"//----------------------------------------------------------------\n"
"/**\n"
" * Evaluate a texture coordinate based on the field value at pos.\n"
" *\n"
" * coefficients - field coefficients [size = (numCells, 8)]\n"
" * pos          - position of fragment in cell parametric space\n"
" * cellId       - the index of the vtkCell that owns this fragment.\n"
" *\n"
" * Note: When visualizing basis functions, this function returns the\n"
" * basis function value at pos.\n"
" *\n"
" */\n"
"vec2 ComputeScalarTexCoord_Hex_C1(in samplerBuffer coefficients, in vec3 pos, in int cellId)\n"
"{\n"
"  float coeff[8]; // coefficients for cellId'th cell.\n"
"  for (int i = 0; i < 8; ++i)\n"
"  {\n"
"    coeff[i] = texelFetch(coefficients, i + 8 * cellId).r;\n"
"  }\n"
"  float x = pos.x;\n"
"  float y = pos.y;\n"
"  float z = pos.z;\n"
"\n"
"  // https://github.com/trilinos/Trilinos/blob/master/packages/intrepid/src/Discretization/Basis/Intrepid_HGRAD_HEX_C1_FEMDef.hpp\n"
"  // Evaluate basis functions.\n"
"  float basis[8];\n"
"  basis[0] = (1.0 - x)*(1.0 - y)*(1.0 - z)/8.0;\n"
"  basis[1] = (1.0 + x)*(1.0 - y)*(1.0 - z)/8.0;\n"
"  basis[2] = (1.0 + x)*(1.0 + y)*(1.0 - z)/8.0;\n"
"  basis[3] = (1.0 - x)*(1.0 + y)*(1.0 - z)/8.0;\n"
"  basis[4] = (1.0 - x)*(1.0 - y)*(1.0 + z)/8.0;\n"
"  basis[5] = (1.0 + x)*(1.0 - y)*(1.0 + z)/8.0;\n"
"  basis[6] = (1.0 + x)*(1.0 + y)*(1.0 + z)/8.0;\n"
"  basis[7] = (1.0 - x)*(1.0 + y)*(1.0 + z)/8.0;\n"
"\n"
"  int visualizeBFuncId = visualizeBasisFunction >= 0 ? visualizeBasisFunction % 8 : -1;\n"
"  if (visualizeBFuncId >= 0)\n"
"  {\n"
"    return vec2(basis[visualizeBFuncId], 0.0f);\n"
"  }\n"
"\n"
"  // Calculate field value from basis functions and the coefficients.\n"
"  float value = 0.0;\n"
"  for (int i = 0; i < 8; ++i)\n"
"  {\n"
"    value += basis[i] * coeff[i];\n"
"  }\n"
"  return vec2(value / (fieldRange.y - fieldRange.x), 0.0f);\n"
"}\n"
"\n"
"//----------------------------------------------------------------\n"
"/**\n"
" * Transform a value from bi-unit space to unit space\n"
" * i.e, a -1....1 space to 0....1 space.\n"
" */\n"
"float BiUnitToUnitDomain(in float value)\n"
"{\n"
"  return 0.5f * (1.0f + value);\n"
"}\n"
"\n"
"//----------------------------------------------------------------\n"
"void main()\n"
"{\n"
"  vec2 texCoord;\n"
"  if (mapScalars != 0)\n"
"  {\n"
"    texCoord = ComputeScalarTexCoord_Hex_C1(fieldCoefficients, pCoordGSOutput, vtkCellIdGSOutput);\n"
"  }\n"
"  else\n"
"  {\n"
"    texCoord = vec2(0.5, 0);\n"
"  }\n"
"\n"
"  // visualize the parametric coordinate if requested.\n"
"  int visualizePCoordId = visualizePCoord >= 0 ? visualizePCoord % 6 : -1;\n"
"  switch (visualizePCoordId)\n"
"  {\n"
"    case 0:\n"
"      texCoord = vec2(BiUnitToUnitDomain(pCoordGSOutput.x), 0);\n"
"      break;\n"
"    case 1:\n"
"      texCoord = vec2(BiUnitToUnitDomain(pCoordGSOutput.y), 0);\n"
"      break;\n"
"    case 2:\n"
"      texCoord = vec2(BiUnitToUnitDomain(pCoordGSOutput.z), 0);\n"
"      break;\n"
"    case 3:\n"
"      texCoord = vec2(BiUnitToUnitDomain(length(pCoordGSOutput.xy)), 0);\n"
"      break;\n"
"    case 4:\n"
"      texCoord = vec2(BiUnitToUnitDomain(length(pCoordGSOutput.yz)), 0);\n"
"      break;\n"
"    case 5:\n"
"      texCoord = vec2(BiUnitToUnitDomain(length(pCoordGSOutput.zx)), 0);\n"
"      break;\n"
"    default:\n"
"      break;\n"
"  }\n"
"\n"
"  //VTK::Normal::Impl\n"
"\n"
"  //VTK::Color::Impl\n"
"\n"
"  //VTK::Light::Impl\n"
"}\n"
"";
