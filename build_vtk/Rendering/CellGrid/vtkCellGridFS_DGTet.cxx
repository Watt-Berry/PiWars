// SPDX-FileCopyrightText: Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
// SPDX-License-Identifier: BSD-3-Clause
#include "vtkCellGridFS_DGTet.h"

const char *vtkCellGridFS_DGTet =
"//VTK::System::Dec\n"
"\n"
"//VTK::Define::Dec\n"
"\n"
"// SPDX-FileCopyrightText: Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"// SPDX-License-Identifier: BSD-3-Clause\n"
"// Template for the cellgrid mapper fragment shader\n"
"\n"
"// look up cell points, types and vertex positions from texture buffers.\n"
"uniform samplerBuffer fieldCoefficients;\n"
"uniform vec2 fieldRange;\n"
"\n"
"// These two help debug parametric coordinates and basis function values.\n"
"uniform int visualizePCoord;\n"
"uniform int visualizeBasisFunction;\n"
"uniform int mapScalars;\n"
"\n"
"//VTK::CustomUniforms::Dec\n"
"\n"
"// Camera prop\n"
"//VTK::Camera::Dec\n"
"\n"
"// Input parametric coord from geometry shader\n"
"in vec3 pCoordGSOutput;\n"
"\n"
"// Input VTK cell ID from vertex shader\n"
"flat in int vtkCellIdGSOutput;\n"
"\n"
"// optional color passed in from the vertex shader, vertexColor\n"
"//VTK::Color::Dec\n"
"\n"
"// cell Normal used to light up and shade the pixels.\n"
"//VTK::Normal::Dec\n"
"\n"
"// Lights\n"
"//VTK::Light::Dec\n"
"\n"
"// the output of this shader\n"
"//VTK::Output::Dec\n"
"\n"
"//----------------------------------------------------------------\n"
"/**\n"
" * Evaluate a texture coordinate based on the field value at pos.\n"
" *\n"
" * coefficients - field coefficients [size = (numCells, 8)]\n"
" * pos          - position of fragment in cell parametric space\n"
" * cellId       - the index of the vtkCell that owns this fragment.\n"
" *\n"
" * Note: When visualizing basis functions, this function returns the\n"
" * basis function value at pos.\n"
" *\n"
" */\n"
"vec2 ComputeScalarTexCoord_Tet_C1(in samplerBuffer coefficients, in vec3 pos, in int cellId)\n"
"{\n"
"  float coeff[4]; // coefficients for cellId'th cell.\n"
"  for (int i = 0; i < 4; ++i)\n"
"  {\n"
"    coeff[i] = texelFetch(coefficients, i + 4 * cellId).r;\n"
"  }\n"
"  float x = pos.x;\n"
"  float y = pos.y;\n"
"  float z = pos.z;\n"
"\n"
"  // https://github.com/trilinos/Trilinos/blob/master/packages/intrepid/src/Discretization/Basis/Intrepid_HGRAD_TET_C1_FEMDef.hpp\n"
"  // Evaluate basis functions.\n"
"  float basis[4];\n"
"  basis[0] = (1.0 - x - y - z);\n"
"  basis[1] = x;\n"
"  basis[2] = y;\n"
"  basis[3] = z;\n"
"\n"
"  int visualizeBFuncId = visualizeBasisFunction >= 0 ? visualizeBasisFunction % 4 : -1;\n"
"  if (visualizeBFuncId >= 0)\n"
"  {\n"
"    return vec2(basis[visualizeBFuncId], 0.0f);\n"
"  }\n"
"\n"
"  // Calculate field value from basis functions and the coefficients.\n"
"  float value = 0.0;\n"
"  for (int i = 0; i < 4; ++i)\n"
"  {\n"
"    value += basis[i] * coeff[i];\n"
"  }\n"
"  return vec2(value / (fieldRange.y - fieldRange.x), 0.0f);\n"
"}\n"
"\n"
"//----------------------------------------------------------------\n"
"void main()\n"
"{\n"
"  vec2 texCoord;\n"
"  if (mapScalars != 0)\n"
"  {\n"
"    texCoord = ComputeScalarTexCoord_Tet_C1(fieldCoefficients, pCoordGSOutput, vtkCellIdGSOutput);\n"
"  }\n"
"  else\n"
"  {\n"
"    texCoord = vec2(0.5, 0);\n"
"  }\n"
"\n"
"  // visualize the parametric coordinate if requested.\n"
"  int visualizePCoordId = visualizePCoord >= 0 ? visualizePCoord % 6 : -1;\n"
"  switch (visualizePCoordId)\n"
"  {\n"
"    case 0:\n"
"      texCoord = vec2(pCoordGSOutput.x, 0);\n"
"      break;\n"
"    case 1:\n"
"      texCoord = vec2(pCoordGSOutput.y, 0);\n"
"      break;\n"
"    case 2:\n"
"      texCoord = vec2(pCoordGSOutput.z, 0);\n"
"      break;\n"
"    case 3:\n"
"      texCoord = vec2(length(pCoordGSOutput.xy), 0);\n"
"      break;\n"
"    case 4:\n"
"      texCoord = vec2(length(pCoordGSOutput.yz), 0);\n"
"      break;\n"
"    case 5:\n"
"      texCoord = vec2(length(pCoordGSOutput.zx), 0);\n"
"      break;\n"
"    default:\n"
"      break;\n"
"  }\n"
"\n"
"  //VTK::Normal::Impl\n"
"\n"
"  //VTK::Color::Impl\n"
"\n"
"  //VTK::Light::Impl\n"
"}\n"
"";
